\section{Desarrollo}
%Deben explicarse los métodos numéricos que utilizaron y su aplicación al problema
%concreto involucrado en el trabajo práctico. Se deben mencionar los pasos que si-
%guieron para implementar los algoritmos, las dificultades que fueron encontrando y la
%descripción de cómo las fueron resolviendo. Explicar también cómo fueron planteadas
%y realizadas las mediciones experimentales. Los ensayos fallidos, hipótesis y conjeturas
%equivocadas, experimentos y métodos malogrados deben figurar en esta sección, con
%una breve explicación de los motivos de estas fallas (en caso de ser conocidas).
\subsection{Estructura de la matriz bandas}
Para representar el sistema de ecuaciones, vamos a implementar una estructura que trabaja internamente con una matriz, la cual guarda únicamente los elementos del sistema que nos interesan. Recordemos primero, que dados $a, b$ y $h$, $n = a/h$, $m = b/h$ entonces estaremos discretizando $(n + 1)$x$(m + 1)$ puntos. 
Dado que hay $(n + 1)$x$(m + 1)$ puntos a los cuales debemos asociarles sus respectivas temperaturas, como sabemos a priori que los bordes tienen una temperatura constante de -100, en realidad nos van a interesar las temperaturas de los demás puntos, es decir de $(n - 1)$x$(m - 1)$ puntos (ya que hay dos bordes horizontales y dos verticales). Sabemos entonces, que si tenemos $(n - 1)$x$(m - 1)$ puntos a los cuales debemos asociarles temperaturas, vamos a tener $(n - 1)$x$(m - 1)$ incógnitas y también $(n - 1)$x$(m - 1)$ ecuaciones lineales. La idea es aprovechar que la matriz asociada al sistema de ecuaciones tiene la forma de una matriz bandas, usando esto a nuestro favor para reducir la complejidad espacial que requiere el problema.
\par La idea es utilizar como dijimos antes, una matriz que represente el sistema de ecuaciones. Para hacer esto, no vamos a poder evitar tener $(n - 1)$x$(m - 1)$ filas debido a que cada fila va a representar cada punto de la discretización. Lo que sí se puede evitar, es tener $(n - 1)$x$(m - 1)$ columnas ya que, al tratarse de una matriz bandas, la ecuación $i$ que representa al punto $X_i$ va a usar a lo sumo a los puntos $X_{i - (m - 1)}$, $X_{i + (m - 1)}$, $X_{i + 1}$ y $X_{i - 1}$. Entonces como sucede esto, con tener $2$x$(m - 1) + 2$ columnas es suficiente. Las dos columnas adicionales que contamos se deben a que necesitamos en cada fila poder representar el valor valor correspondiente al coeficiente del punto $X_i$ y, dado que vamos a guardar la matriz asociada al sistema, ésta va a ser de la forma $A|b$, por lo tanto necesitamos una columna más para los elementos de $b$. Utilizando una matriz de estas dimensiones, nuestra complejidad espacial para representar el sistema pasa de ser $O((n - 1)^2(m - 1)^2)$ a ser $O((n - 1)(m - 1)^2)$.
\par Hasta ahora lo que explicamos es simplemente que es posible almacenar la matriz asociada al sistema de ecuaciones de una manera más eficiente que guardándola todos sus valores. En nuestra implementación, lo que hicimos es que la estructura que representa el sistema de ecuaciones, mantenga privada esta matriz de $(n - 1)$x$(2(m - 1) + 2)$ de manera tal que cuando queramos acceder a un elemento de la matriz que representa lo hagamos como si estuvieramos tratando con la matriz entera. Para esto, es necesario poder "mapear" de alguna manera cada elemento de la matriz asociada al sistema de ecuaciones, a la matriz que utiliza internamente nuestra estructura para representarla. Explicaremos a continuación, la lógica detrás del mapeo este:
\newline Sea $A_{ij}$ $1 \leq i \leq n - 1, 1 \leq j \leq m - 1$ un elemento de la matriz asociada al sistema de ecuaciones que queremos resolver $A \in \mathbb{R}^{(n - 1)x(m - 1)}$ y sea $A' \in \mathbb{R}^{(n - 1)x(2(m - 1) + 2)}$ la matriz interna que utiliza nuestra estructura para representar a $A$:
\begin{itemize}
\item Si $i = j$, entonces $A_{ij} = A'_{i (m + 1)}$ debido a que estamos tratando de acceder al coeficiente de la incógnita correspondiente a la fila $i$ y, por una cuestión de implementación decidimos situarlo en el medio de cada fila.
\item Si $j = m - 1$ entonces $A_{ij} = A'_{ij}$ ya que estamos tratando de acceder a un $b_i$ y el vector $b$ de resultados de las ecuaciones queda almacenado de manera intacta.
\item Si $j > i$ estamos tratando de acceder a un elemento que está a la derecha (en nuestra matriz interna) del elemento que almacena el coeficiente de la incógnita correspondiente a esta fila
\begin{itemize}
\item Si $j - i \leq m - 1$ entonces quiere decir que tenemos almacenado a este elemento y por lo tanto $A_{ij} = A'_{i, m + j - i}$
\item Caso contrario $A_{ij} = 0$ ya que estamos tratando de acceder al coeficiente (en la ecuación $i$) de un punto que seguro esta ecuación no utiliza.
\end{itemize}
\item Si $j < i$ estamos tratando de acceder a un elemento que está a la izquierda (en nuestra matriz interna) del elemento que almacena el coeficiente de la incógnita correspondiente a esta fila.
\begin{itemize}
\item Si $j - i \leq m - 1$ entonces quiere decir que tenemos almacenado a este elemento y por lo tanto $A_{ij} = A'_{i, m - (i - j)}$.
\item Caso contrario $A_{ij} = 0$ ya que estamos tratando de acceder al coeficiente de un punto que seguro esta ecuación no utiliza.
\end{itemize}
\end{itemize}
\subsection{Eliminación Gaussiana vs Factorización LU}
La idea en esta sección es analizar ambos métodos y realizar una suerte de comparación para ver cuando es que conviene utilizar uno y cuando el otro. Si bien los dos nos ayudan a resolver un sistema de ecuaciones lineales y están estrechamente vinculados, existen ocasiones donde utilizar LU en lugar de Eliminación Gaussiana, puede ahorrarnos mucho tiempo de cómputo. Para empezar, es importante recordar que \textit{no siempre} vamos a poder factorizar una matriz y por ende, cuando esto suceda no va a quedar otra opción que utilizar Eliminación Gaussiana. Para poder hacer la comparación entonces, vamos a asumir que en los casos que nombremos se va a poder utilizar el método de factorización.
\par A priori, la complejidad teórica de ambos algoritmos es $O(n^3)$ así que eso no nos dice cúal es mejor en la práctica, por lo tanto habrá que probar ambos para el caso particular con el cúal estemos trabajando y de ahí decidir cúal se comporta mejor. Llamemos $A|b$ al sistema de ecuaciones lineales asociado al problema que queremos resolver. Si nuestro objetivo es simplemente resolver ese sistema y de ahí en más trabajar únicamente con esa solución, entonces sí la mejor idea es probar ambos algoritmos y ver cúal se comporta mejor en la práctica. Ahora, podría suceder que el problema no sea solo eso, si no que necesitemos resolver $A|b_1$, $A|b_2$, ... , $A|b_t$ donde lo únco que varía es el $b_i$. En estos casos el método de Factorización LU es claramente superior al método de Eliminación Gaussiana en términos de tiempo de cómputo. Esto se debe a que, si bien encontrar a $L$ (triangular inferior) y a $U$ (triangular superior) tales que $A = LU$ es $O(n^3)$ al igual que el algoritmo de Eliminación Gaussiana, una vez que ya hicimos este paso, resolver cada uno de los $A|b_i$ tiene complejidad $O(n^2)$. Si utilizaramos Eliminación Gaussiana, estaríamos pagando un costo de $O(n^3)$ por cada sistema $A|b_i$ que resolvamos. Esto quiere decir que en este caso, resolver el problema completo con el método de factorización es $O(n^3 + t.n^2)$ mientras que por Eliminación Gaussiana $O(t.n^3)$. Es fácil ver que si $t$ es grande, entonces la brecha entre el tiempo de cómputo consumido por resolver el problema utilizando Eliminación Gaussiana y utilizando Factorización LU va a ser grande también. Incluso si $t$ no es grande puede haber una diferencia notable en la práctica, ya que cuando hablamos de complejidad teórica estamos hablando en términos asintóticos.
\par En el contexto del trabajo práctico, el método de Factorización LU juega un papel importante a la hora de utilizar la fórmula de Sherman-Morrison. Esto se debe a que hay que computar $A^{-1}b$ y $A^{-1}u$, lo que equivale a resolver los sistemas $Ax_1 = b$ y $Ax_2 = u$ y ahí es donde podemos reusar la $L$ y la $U$. En el caso de tener una cantidad considerable de sanguijuelas unitarias, el tiempo de cómputo ahorrado es grande, ya que por cada sanguijuela unitaria que haya se va a estar pagando un costo de $O(n^2)$ utilizando LU contra uno de $O(n^3)$ utilizando Eliminación Gaussiana.
\subsection{Experimento: calidad/tiempo de cómputo}
La idea del siguiente experimento, es tratar de ver como se relaciona el tiempo de cómputo necesario para resolver el sistema de ecuaciones planteado, con la calidad de la solución encontrada. Es importante para esto, decir a qué nos referimos cuando hablamos de calidad. Es necesario para responder esta pregunta, recordar que nuestro objetivo es calcular la temperatura en cierto punto del parabrisas. Para lograr esto, lo que hacemos es discretizar la superficie (porque estamos trabajando con aritmética finita) y pasar de una superficie que tiene infinitos puntos a una representación de dicha superficie con una cantidad finita de puntos. Ahora bien, cuando realizamos la discretización y pasamos de un problema en el espacio continuo a uno en el espacio discreto estamos perdiendo información. Entonces cuando hablamos de calidad, nos referimos justamente a cuanta información estamos perdiendo, como costo de modelar en problema de manera discreta.
\par El experimento se planteó para trabajar con instancias de 20x20 y 40x40, a los fines del mismo, la temperatura y posición de las sanguijuelas no tienen mucha relevancia como sí la tienen la granularidad y los radios de dichas sanguijuelas. Basícamente, se tomó una instancia de 20x20 generada de manera manual y se fueron modificando los valores de los radios y granularidad. En la elección de la instancia de 40x40 lo que importa pasa a ser la cantidad de sanguijuelas, por eso es que se generó de manera distinta (ver epígrafe del resultado del experimento).
\par Una vez que fijamos la instancia que vamos a utilizar y a ir modificando para realizar las mediciones, lo que se va a medir es como varía la temperatura en el punto crítico y tiempo de cómputo en función de la granularidad, la cantidad de sanguijuelas y el tamaño de los radios. Utilizaremos el algoritmo de Eliminación Gaussiana (modo 0). Los tiempos fueron tomados en segundos.
\newline \par Ahora que sabemos qué es lo que se intenta determinar en el experimento, vamos a tratar de pensar qué es lo que debería pasar (y luego contrastarlo con los resultados para ver si efectivamente es lo que sucede) a grandes rasgos, planteando así una serie de hipótesis. 
\begin{enumerate}
\item En cuanto al tiempo de cómputo, sabemos que como vamos a estar utilizando el algoritmo de Eliminación Gaussiana, la cota teórica va a ser $O(n^3)$. El sistema de ecuaciones con el que trabajaremos va a ser de $n'$x$n'$ donde $n' = (b/h - 1)$x$(a/h - 1)$ siendo $a$ (ancho del parabrisas), $b$ (alto del parabrisas), $h$ (granularidad) parámetros del problema. Podemos ver como el tamaño del sistema (y por lo tanto el tiempo de cómputo ya que es una función del tamaño) depende directamente de $h$, de manera tal que si $h$ es chico, entonces el tamaño es grande. Esto nos dice entonces que, dado una instancia del parabrisas (con sus dimensiones y sanguijuelas), cuanto más chico sea $h$, más tiempo se va a tardar en resolver el problema.
\item Dado que para poder computar la temperatura de los puntos de nuestra discretización es necesario saber cuáles de ellos son afectados por alguna sanguijuela, una cantidad grande de sanguijuelas impacta negativamente en el tiempo de cómputo.
\item Debido a que perdemos información al discretizar el problema porque estamos trabajando con un espacio discreto, cuando en realidad el problema es de naturaleza continua, parece razonable pensar que cuanto más chico sea $h$, la solución obtenida va a estar más cerca de la real.
\item Nuestra última hipótesis se desprende de alguna manera de la que enunciamos en el punto anterior. Si al aumentar el tamaño de nuestra discretización estamos acercándonos más a la verdadera solución del problema y las temperaturas de los puntos dependen de las sanguijuelas, parece razonable pensar que haciendo esto tenemos menos chances de descartar sanguijuelas, ya que nuestra discretización es "más adecuada".
\newline
\par 
\end{enumerate}


