\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{charter}   % tipografia
\usepackage{graphicx}

\usepackage{subfig}
\usepackage{float}
%\usepackage{makeidx}

%\usepackage{float}
%\usepackage{amsmath, amsthm, amssymb}
%\usepackage{amsfonts}
%\usepackage{sectsty}
%\usepackage{charter}
%\usepackage{wrapfig}
\usepackage{listings}
%\lstset{language=C}
\usepackage[nosumlimits]{amsmath}

\input{codesnippet}
\input{page.layout}
% \setcounter{secnumdepth}{2}
\usepackage{underscore}
\usepackage{caratulaV}
\usepackage{url}
\usepackage{alltt}
\usepackage{tikz}
\usepackage{color}
% \usepackage{gnuplottex}
\usepackage{verbatim}
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{listings}
\usepackage{color}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
  language=Python,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  numbers=left,
  xleftmargin=2em,
  frame=single,
  framexleftmargin=2em,
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\small\color{gray} % the style that is used for the line-numbers
 }

\parskip = 5 pt

\newcounter{row}
\newcounter{col}

\newcommand\setrow[3]{
	\setcounter{col}{1}
	\foreach \n in {#1, #2, #3} {
	\edef\x{\value{col} - 0.5}
	\edef\y{3.5 - \value{row}}
	\node[anchor=center] at (\x, \y) {\n};
	\stepcounter{col}
	}
	\stepcounter{row}
}

\newcommand\setrowaux[7]{
	\setcounter{col}{1}
	\foreach \n in {#1, #2, #3, #4, #5, #6, #7} {
	\edef\x{\value{col} - 0.5}
	\edef\y{7.5 - \value{row}}
	\node[anchor=center] at (\x, \y) {\n};
	\stepcounter{col}
	}
	\stepcounter{row}
}





\begin{document}


\thispagestyle{empty}
\materia{Métodos Numéricos}
\submateria{Primer Cuatrimestre - 2015}
\titulo{Trabajo Práctico III}
\subtitulo{Marche un telebeam Don Niembraaaaaa...}
\integrante{}{}{}
\integrante{}{}{}
\integrante{}{}{}
\integrante{}{}{}

\maketitle
\newpage


\vspace{3cm}
\tableofcontents
\thispagestyle{empty}

\newpage


\begin{comment}
\begin{codesnippet}
\begin{verbatim}

struct Pepe {

    ...

};

\end{verbatim}
\end{codesnippet}

\begin{lstlisting}
for (x = 1 to n - 2):
	xmm1  <--  img[x-1][0] , img[x][0] , img[x+1][0] , img[x+2][0]
	xmm2  <--  img[x-1][1] , img[x][1] , img[x+1][1] , img[x+2][1]
	xmm1  <--  borrarprimero(xmm1)
	xmm2  <--  borrarprimero(xmm2)
	xmm1  <--  sumapixels(xmm1)
	xmm2  <--  sumapixels(xmm2)
	for (y = 1 to n - 2): 
		xmm0  <--  xmm1
		xmm1  <--  xmm2
		xmm3  <--  img[x-1][y+1] , img[x][y+1] , img[x+1][y+1] , img[x+2][y+1]
		xmm3  <--  borrarprimero(xmm3)
		xmm3  <--  sumapixels(xmm3)
		xmm0  <--  xmm0 + xmm1 + xmm2
		xmm0  <--  promedio(xmm0)
		img[x][y]  <--  xmm0
	end
end
\end{lstlisting}


\begin{figure}[H]
\centering
\includegraphics[scale=0.8]{imagenes/256value.png}
\caption{Contenido de los registros utilizados para multiplicar}
\label{256value}
\end{figure}



\begin{figure}[H]
	\minipage{0.5\textwidth}
	\begin{center}
		\includegraphics[scale=0.4]{../tp2-bundle.v2/Testing/plots/all/merge-black-05--all.png}
		\caption{Rendimiento para un value de 0.5, imágenes negras.}
		\label{fig:exp1-5}
	\end{center}
	\endminipage\hfill
	\minipage{0.5\textwidth}
	\begin{center}
		\includegraphics[scale=0.4]{../tp2-bundle.v2/Testing/plots/all/merge-normal-00--all.png}
		\caption{Rendimiento para un value de 0.0, imágenes normales.}
		\label{fig:exp1-2}
	\end{center}
	\endminipage\hfill
\end{figure}


\end{comment}

\setcounter{page}{1}


\begin{abstract}

En este trabajo se utilizaran distintas técnicas para obtener un re-escalamiento de imágenes. Se utilizara vecino más cercano, interpolación de polinomios bilineal, splines cúbicos, y distintas variantes de los métodos anteriormente mencionados. Se implementaran algoritmos para los mismos, dando la posibilidad de re-escalar las imágenes en distintos tamaños(siempre mayor al original). Se llevara a cabo una experimentación con su respectivo análisis. Como las imágenes obtenidas, no contienen integramente información original, se utilizaran las métricas de Error Cuadrático Medio (ECM) y Peak to Signal Noise Ratio (PSNR) para estudiar en forma cuantitativa la calidad de las mismas. También se considerara la calidad subjetiva, y el tiempo de computo. 

\textbf{Palabras Clave}: re-escalamiento imágenes, interpolación, ECM, PSNR

\end{abstract}


\section{Intoducción}

Las imágenes digitales se obtienen a través de dispositivos de conversión análogico-digital como un escáner, una cámara fotográfica digital o directamente desde el ordenador utilizando cualquier programa de tratamiento de imágenes. La información digital que genera cualquiera de los medios citados es almacenada en la computadora mediante bits (unos y ceros). 

Hay distintos tipos de formatos, pero a grandes rasgos se clasifican en imágenes mapa de bits e imágenes vectoriales. En general contienen una cabecera que contiene atributos (dimensiones de la imagen, tipo de codificación, etc.), seguida de los datos de la imagen en sí misma. La estructura de los atributos y de los datos de la imagen es distinto en cada formato. También puede contener metadatos, con información extra, como por ejemplo la fecha y lugar de creación en el caso de una imagen tomada con una camara digital.

Los formatos de mapa de bits representan a la imagen como una matriz de pixeles. Estos son la menor unidad homogénea en color que forma parte de una imagen. Hay que tener presente que los mismos no tienen un tamaño especifico, ya que depende del tamaño del monitor con que se visualiza la imagen, o del zoom que se aplique sobre la misma. A su vez cada formato tiene una forma especifica de representar el color de un pixel, las principales son el RGB (rojo, verde y azul), el HLS (tono, luminosidad, saturación) y el CMYK (cian, magenta, amarillo y negro), escala de grises( cada color es una tonalidad distinta del gris).

De esta manera las podemos caracterizar a las imágenes por su altura y anchura (en píxeles) y por su profundidad de color (en bits por píxel), que determina el número de colores distintos que se pueden almacenar en cada punto individual. Los principales formatos de mapas de bits son los siguientes: BMP, TIFF, XCF, PICT, JPG, GIF, PNG, PSD.

Por otra parte los formatos vectoriales representan a la imagen con objetos geométricos independientes (segmentos, polígonos, arcos, etc.), cada uno de ellos definido por distintos atributos matemáticos de forma, de posición, de color, etc. Las líneas que componen la imagen están definidas por vectores (de ahí su nombre). El interés principal de los gráficos vectoriales es poder ampliar el tamaño de una imagen a voluntad sin sufrir la pérdida de calidad que sufren los mapas de bits. De la misma forma, permiten mover, estirar y retorcer imágenes de manera relativamente sencilla. Actualmente los procesadores traducen los gráficos vectoriales a mapas de bits para poder representarlos en pantalla. El formato mas utilizado es SVG.

En este trabajo para re-escalar imágenes utilizando los distintos métodos, primero se las convertirá a escala de grises, y luego se aplicara el algoritmo. Se utilizaran los métodos de vecino más cercano, interpolación de polinomios bilineal, splines cúbicos. También distintas variantes de los anteriores.

La interpolación de polinomios consiste en dada una terna de puntos ($ x_{0} $, $ y_{0} $), ($ x_{1} $, $ y_{1} $), $ \ldots $ ($ x_{n} $, $ y_{n} $), obtener un polinomio que los interpole, es decir que verifique $ p(x_{0}) =  y_{0} $, $ p(x_{1}) =  y_{1} $, $ \ldots $ $ p(x_{n}) =  y_{n} $. En general, la interpolación de una serie de puntos es usada para aproximar una función continua en un cierto intervalo. Los polinomios son funciones continuas, de clase $ C^{\infty} $, además es muy fácil trabajar con ellos, y suelen aproximar bien a las funciones continuas que típicamente se usan. En general se utiliza el polinomio de menor grado que verifique la anterior condición, ya que los polinomios de grado mas grande pueden tener mayor cantidad de oscilaciones.

Se puede garantizar la existencia del polinomio interpolador, ya que hay un teorema que establece que dado un conjunto de $ n +1 $ puntos $ \exists! $ polinomio de grado a lo sumo n que interpole. Hay distintos métodos para obtener a este ultimo. Uno de ellos es el método de interpolación de lagrange, el cual se basa en construir primero los polinomios $ L_{n,k} $ definidos como se indica en la ecuación~\ref{Ls}.

\begin{equation}
L_{n,k}= \prod_{\substack{i=0\\i\neq k}} \frac{(x-x_{i})}{(x_{k}-x_{i})}
\label{Ls}
\end{equation}

Estos últimos tienen grado $ n $ y se verifica que  $ L_{n,k}(x_{i})= 0 $ y que $ L_{n,k}(x_{k})= 1 $. El polinomio de grado a lo sumo $ n $ que interpola los $ n +1 $ puntos se construye según la ecuación~\ref{lagrange}.

\begin{equation}
p(x)= \sum_{k=0}^{n}y_{k}L_{n,k}(x)
\label{lagrange}
\end{equation}

Por ejemplo para realizar una interpolación bilineal entre dos puntos ($ x_{0} $, $ y_{0} $) y ($ x_{1} $, $ y_{1} $), el polinomio interpolador de lagrange sera de grado a lo sumo uno, por lo será una recta que pasa por dos puntos. En la ecuación~\ref{bilinealInter}

\begin{equation}
p(x)= L_{1,0}(x)y_{0} + L_{1,1}(x)y_{1}
\label{bilinealInter}
\end{equation}

Despejando la ecuación~\ref{bilinealInter} obtenemos una formula mas clara para el mismo, donde además podemos distinguir la pendiente y la ordenada al origen.

\begin{equation}
p(x)= \frac{y_{1}-y_{0}}{x_{1}-x_{0}} x - x_{0} \frac{y_{1}-y_{0}}{x_{1}-x_{0}} + y_{0}
\label{bilineal}
\end{equation}



\newpage 

\section{Desarollo}

\begin{figure}[!h]
%\begin{subfigure}[c]{0.45\textwidth}
\begin{center}
	\begin{tikzpicture}
    	\fill[gray!20](0,0) rectangle (1,1); 
    	\fill[white!20](0,1) rectangle (1,2); 
    	\fill[white!20](0,2) rectangle (1,3); 
    	\fill[gray!20](0,3) rectangle (1,4); 
    	\fill[white!20](0,4) rectangle (1,5); 
    	\fill[white!20](0,5) rectangle (1,6); 
    	\fill[gray!20](0,6) rectangle (1,7); 
		\fill[white!20](1,0) rectangle (2,7);
		\fill[white!20](2,0) rectangle (3,7);
    	\fill[gray!20](3,0) rectangle (4,1); 
    	\fill[white!20](3,1) rectangle (4,2); 
    	\fill[white!20](3,2) rectangle (4,3); 
    	\fill[gray!20](3,3) rectangle (4,4); 
    	\fill[white!20](3,4) rectangle (4,5); 
    	\fill[white!20](3,5) rectangle (4,6); 
    	\fill[gray!20](3,6) rectangle (4,7); 
		\fill[white!20](4,0) rectangle (5,7);
		\fill[white!20](5,0) rectangle (6,7);
    	\fill[gray!20](6,0) rectangle (7,1); 
    	\fill[white!20](6,1) rectangle (7,2); 
    	\fill[white!20](6,2) rectangle (7,3); 
    	\fill[gray!20](6,3) rectangle (7,4); 
    	\fill[white!20](6,4) rectangle (7,5); 
    	\fill[white!20](6,5) rectangle (7,6); 
    	\fill[gray!20](6,6) rectangle (7,7); 
	  	\draw (0,0) grid (7,7);

		\setcounter{row}{1}
		\setrowaux {1}{}{}{2}{}{}{3}
		\setrowaux {}{}{}{}{}{}{}
		\setrowaux {}{}{}{}{}{}{}
		\setrowaux {4}{}{}{5}{}{}{6}
		\setrowaux {}{}{}{}{}{}{}
		\setrowaux {}{}{}{}{}{}{}
		\setrowaux {7}{}{}{8}{}{}{9}
	\end{tikzpicture}
\end{center}
\caption{Imagen re-escalada}
\label{fig:imgnew}
%\end{subfigure}
\end{figure}

\section{Experimentación}








\section{Conclusiones}


\end{document}

